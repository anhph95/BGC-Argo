import gsw
import numpy as np
from scipy.signal import savgol_filter, find_peaks
import pandas as pd

'''
Function to calculate habitat defining variable of a single float cycle from BGC-ARGO
Input:
- mydata: input BGC-ARGO data download by argo_download.py
- n2.smooth: option to apply smoothing function on buoyancy frequency (N2), will affect local maxima
- n2.local.max: select n-th local maximum from surface, set to FALSE for global maximum
- chla.smooth: option to apply smoothing function on chl a, will affect local maxima
- chla.local.max: select n-th local maximum from surface, set to FALSE for global maximum
- nai.bound: boundary for NAI calculation, default is 2 uM as in Weber et al. 2019
- plot: option to plot N2, Chla, and [NO3] profiles
- zmax: depth limit plot, set to FALSE for profile bottom depth
'''

def hbt(mydata, n2_smooth=True, n2_local_max=False, chla_smooth=False, chla_local_max=False, nai_bound=1.5, threshold=0.2, flag = [1,2,8]):
    # ============ Float basic info ============
    Float = mydata.PLATFORM_NUMBER.astype(str).item().replace(' ', '')
    Cycle = mydata.CYCLE_NUMBER.item()
    Float_Cycle = '_'.join((str(Float), str(int(Cycle))))
    Date = mydata.JULD.dt.strftime('%m/%d/%Y %H:%M:%S').item()
    Year = mydata.JULD.dt.year.item()
    Month = mydata.JULD.dt.month.item()
    Hour = mydata.JULD.dt.hour.item()
    Season = mydata.JULD.dt.season.item()
    Daynight = 'Night' if Hour < 6 or Hour > 18 else 'Day'
    lat = mydata.LATITUDE.item()
    lon = mydata.LONGITUDE.item()
    note = ''

    # Temporary data for calculation
    pressure = mydata['PRES_ADJUSTED'].values
    salinity = mydata['PSAL_ADJUSTED'].values
    temp = mydata['TEMP_ADJUSTED'].values
    # Calculate depth from pressure
    depth = -np.asarray(gsw.conversions.z_from_p(pressure, lat, geo_strf_dyn_height=0, sea_surface_geopotential=0))
    # Calculate potential density from temperature, salinity
    #sig = gsw.density.sigma0(salinity, temp)
    
    try:
        chlacol = mydata['CHLA_ADJUSTED'].values
        chlaQC = mydata['CHLA_ADJUSTED_QC'].astype(float).values
    except Exception:
        SCHL = np.nan
        ChlMD = np.nan
        chlacol = np.nan*np.ones(np.size(temp))
        chlaQC = np.nan*np.ones(np.size(temp))
        note += f'CHLA_ADJUSTED not exist, '

    try:
        nacol = mydata['NITRATE_ADJUSTED'].values
        naQC = mydata['NITRATE_ADJUSTED_QC'].astype(float).values
    except Exception:
        nai = np.nan
        nacol = np.nan*np.ones(np.size(temp))
        naQC = np.nan*np.ones(np.size(temp))
        note += f'NITRATE_ADJUSTED not exist, '
    
    alltable = pd.DataFrame((depth,nacol,chlacol,naQC,chlaQC)).T.sort_values(by=0).reset_index(drop=True)
    alltable.columns=['d','n','chla','naQC','chlaQC']
    
    # ========== CALCULATE SST, SSS ============
    # Sea surface temperature and sea surface salinity
    SST = np.nan
    SSS = np.nan
    try:
        SST = temp[~np.isnan(temp)][np.nanargmin(depth[~np.isnan(temp)])]
    except Exception:
        note += f'SST error, '
        pass

    try:
        SSS = salinity[~np.isnan(salinity)][np.nanargmin(depth[~np.isnan(salinity)])]
    except Exception:
        note += f'SSS error, '
        pass

    # ========== CALCULATE MLD ============ 
    # Mixed layer depth
    # Calculate squared buoyancy frequency from potential density, apply smoothing function if prompted
    MLD = np.nan  
    try:
        if np.isnan(salinity).all() or np.isnan(temp).all():
            note += f'MLD error, '
        else:
            n2 = np.asarray(gsw.Nsquared(salinity, temp, pressure, lat))[0]
            n2[n2==np.inf]=np.nan
            n2[n2==-np.inf]=np.nan
            if (n2_smooth):
                n2 = savgol_filter(n2,10,2) # window size 20, polynomial order 2
            
            # Find all depth of local maxima for buoyancy
            if ~np.isnan(n2).all():
                MLD_peak,_ = find_peaks(n2,prominence=(np.nanmax(n2)-np.nanmin(n2))*threshold)
                MLD_list = depth[1:][MLD_peak]
                # Extract local/global maximum for buoyancy
                if (n2_local_max) and (np.size(MLD_peak)!=0):
                    MLD = MLD_list[n2_local_max-1]
                else:
                    if np.size(MLD_peak) == 0:
                        MLD = depth[1:][np.nanargmax(n2)]
                    else:
                        MLD = depth[1:][n2==np.nanmax(n2[MLD_peak])]
            else:
                note += f'MLD error, '

    except Exception:
        note += f'MLD error, '
        pass

    # ========== CALCULATE ChlMD & SChl ==========
    # Depth or chlorophyll maximum and surface chlorophyll
    # Filter flag
    table = alltable[np.in1d(alltable.chlaQC, flag)].reset_index(drop=True)
    # Extract Chl a
    ChlMD = np.nan
    SCHL = np.nan
    if np.size(table.d) == 0:
        note += 'No QC CHL data, '
    elif table.d[np.nanargmin(table.d)] > 200:
        note += 'Insufficient surface CHL data, '
    else:
        try:
            if (chla_smooth):
                chla = savgol_filter(table.chla,20,2)
            else:
                chla = table.chla
            # Surface Chla
            SCHL = chla[np.nanargmin(table.d)]
            # Find all depth of local maxima for chl a
            if ~np.isnan(chla).all():
                ChlMD_peak,_ = find_peaks(chla,prominence=(np.nanmax(chla)-np.nanmin(chla))*threshold)
                ChlMD_list = table.d[ChlMD_peak].values
                # Extract local/global maximum for chl a
                if (chla_local_max) and (np.size(ChlMD_peak)!=0):
                    ChlMD = ChlMD_list[chla_local_max-1]
                else:
                    if np.size(ChlMD_peak!=0):
                        ChlMD = table.d[chla==np.nanmax(chla[ChlMD_peak])].values
                    else:
                        ChlMD = table.d[np.nanargmax(chla)]
                        note += 'No CHL peak found, use max value, '
            else:
                note += f'ChlMD error, '
        except Exception:
            note += f'ChlMD error, '
            pass

    # ========== CALCULATE NAI/DNC ===========
    # Depth of nitracline or nitrate availability index
    # Filter flag
    table = alltable[np.in1d(alltable.naQC, flag)].reset_index(drop=True)
    # If surface [NO3] >= boundary then NAI = surface [NO3]
    # If surface [NO3] <= boundary and bottom [NO3] >= boundary then integrate depth for [NO3]=boundary
    # If bottom [NO3] <= boundary then NAI = minus bottom depth
    nai = np.nan
    dnc = np.nan
    # DNC
    if np.size(table.d) == 0:
        note += 'No QC NITRATE data, '
    elif table.d[np.nanargmin(table.d)] > 200:
        note += 'Insufficient surface NITRATE data, '
    else:
        try:
            dn = np.gradient(table.n,table.d)
            dn[dn==np.inf]=np.nan
            dn[dn==-np.inf]=np.nan
            N_peak,_ = find_peaks(dn,prominence=(np.nanmax(dn)-np.nanmin(dn))*threshold)
            if np.size(N_peak) != 0:
                dnc = table.d[dn==np.nanmax(dn[N_peak])].values
            else:
                dnc = table.d[np.nanargmax(dn)]
                note += 'No nitrate peak found, use max value, '
        except Exception:
            note += f'DNC error, '
            pass
        
        # NAI   
        try:
            if table.n[np.nanargmin(table.d)] >= nai_bound:
                nai = table.n[np.nanargmin(table.d)]
            elif (table.n[np.nanargmin(table.d)] < nai_bound) and (np.nanmax(table.n) > nai_bound): # interpolate around nai_bound
                i = table.n[table.n >= nai_bound].index[0]
                k = i - 1
                nai = -(table.d[k] + (nai_bound - table.n[k]) * (table.d[i] - table.d[k]) / (table.n[i] - table.n[k]))
            else:
                nai = -table.d[np.nanargmax(table.d)]
        except Exception:
            note += f'NAI error, '
            pass

    # ========== EXPORT RESULT ==========
    data = np.column_stack((Float, Cycle, Float_Cycle, Date, Season, Daynight,
                            Year, Month, Hour, lat, lon,
                            MLD, ChlMD, SST, SSS,  dnc, nai, SCHL,
                            str(flag).replace('[','').replace(']',''),note))
    cols = ['Float', 'Cycle', 'Float_cycle', 'Date','Season','Daynight',
            'Year','Month', 'Hour','Lat', 'Lon', 'MLD', 'ChlMD', 'SST', 'SSS', 'DNC','NAI','SChl','QC','Note']
    result = pd.DataFrame(data, index=None, columns=cols)
    return(result)